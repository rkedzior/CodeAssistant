<!doctype html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Indexing</title>
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        margin: 2rem;
      }
      .card {
        max-width: 720px;
        padding: 1.5rem;
        border: 1px solid #ddd;
        border-radius: 8px;
      }
      .status {
        margin-top: 1rem;
        padding: 0.75rem;
        border-radius: 6px;
        border: 1px solid #ddd;
        background: #fafafa;
      }
      .actions {
        margin-top: 1.25rem;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }
      button {
        padding: 0.6rem 1rem;
        border: 0;
        border-radius: 6px;
        background: #1f6feb;
        color: #fff;
        cursor: pointer;
      }
      button.secondary {
        background: #6b7280;
      }
      button.danger {
        background: #b91c1c;
      }
      input[type="text"] {
        padding: 0.55rem 0.75rem;
        border: 1px solid #ddd;
        border-radius: 6px;
        flex: 1;
        min-width: 240px;
      }
      a {
        color: #1f6feb;
        text-decoration: none;
      }
      .notice {
        background: #e7f3ff;
        border: 1px solid #b6d8ff;
        padding: 0.75rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }
      .muted {
        color: #666;
      }
    </style>
  </head>
  <body th:with="isConfigured=${#ctx.containsVariable('configured') and (configured == true)}">
    <div class="card">
      <h1>Indexing</h1>

      <div class="notice" th:if="${!isConfigured}">
        <div>Project is not configured yet.</div>
        <div class="muted">Configure the project before running indexing.</div>
      </div>

      <div class="status">
        <div>
          Job status:
          <strong id="jobStatus" th:text="${job.status}">IDLE</strong>
        </div>
        <div style="margin-top: 0.5rem">
          Progress:
          <strong id="jobProgress" th:text="${job.progress}">Idle</strong>
        </div>
        <div id="ingestionRow" style="margin-top: 0.5rem; display: none">
          Ingestion:
          <strong id="ingestionUploaded">0</strong> uploaded,
          <strong id="ingestionProcessing">0</strong> processing,
          <strong id="ingestionReady">0</strong> ready,
          <strong id="ingestionFailed">0</strong> failed
        </div>
        <div id="ingestionFailures" style="margin-top: 0.5rem; display: none">
          Failed files:
          <ul id="ingestionFailureList"></ul>
        </div>
        <div id="jobErrorRow" style="margin-top: 0.5rem; display: none">
          Error:
          <strong id="jobError"></strong>
        </div>
      </div>

      <div class="actions">
        <button id="runBtn" th:disabled="${!isConfigured}">Run initial index</button>
        <a th:href="@{/}">Back to Dashboard</a>
      </div>

      <div class="actions" style="margin-top: 1rem">
        <input
          id="commitInput"
          type="text"
          th:disabled="${!isConfigured}"
          placeholder="Commit hash (e.g. abc1234)"
          autocomplete="off"
        />
        <button id="updateBtn" class="danger" th:disabled="${!isConfigured}">Update index to commit</button>
        <button id="reloadBtn" class="danger" th:disabled="${!isConfigured}">Full reload</button>
      </div>

      <div id="confirmBox" class="status" style="display: none">
        <div>
          Confirm: run the initial index using the repository <strong>HEAD</strong> commit?
        </div>
        <div class="actions">
          <button id="confirmBtn" class="danger">Confirm and start</button>
          <button id="cancelBtn" class="secondary">Cancel</button>
        </div>
      </div>

      <div id="confirmUpdateBox" class="status" style="display: none">
        <div>
          Confirm: update the index from <strong id="updateFromCommit">Unknown</strong> to
          <strong id="updateToCommit">?</strong>?
        </div>
        <div class="actions">
          <button id="confirmUpdateBtn" class="danger">Confirm and start</button>
          <button id="cancelUpdateBtn" class="secondary">Cancel</button>
        </div>
      </div>

      <div id="confirmReloadBox" class="status" style="display: none">
        <div>
          Confirm: fully reload the index at <strong id="reloadCommit">?</strong>?
        </div>
        <div class="actions">
          <button id="confirmReloadBtn" class="danger">Confirm and start</button>
          <button id="cancelReloadBtn" class="secondary">Cancel</button>
        </div>
      </div>
    </div>

    <script>
      const runBtn = document.getElementById("runBtn");
      const confirmBox = document.getElementById("confirmBox");
      const confirmBtn = document.getElementById("confirmBtn");
      const cancelBtn = document.getElementById("cancelBtn");

      const commitInput = document.getElementById("commitInput");
      const updateBtn = document.getElementById("updateBtn");
      const reloadBtn = document.getElementById("reloadBtn");
      const confirmUpdateBox = document.getElementById("confirmUpdateBox");
      const confirmUpdateBtn = document.getElementById("confirmUpdateBtn");
      const cancelUpdateBtn = document.getElementById("cancelUpdateBtn");
      const updateFromCommit = document.getElementById("updateFromCommit");
      const updateToCommit = document.getElementById("updateToCommit");

      const confirmReloadBox = document.getElementById("confirmReloadBox");
      const confirmReloadBtn = document.getElementById("confirmReloadBtn");
      const cancelReloadBtn = document.getElementById("cancelReloadBtn");
      const reloadCommit = document.getElementById("reloadCommit");

      const jobStatus = document.getElementById("jobStatus");
      const jobProgress = document.getElementById("jobProgress");
      const ingestionRow = document.getElementById("ingestionRow");
      const ingestionUploaded = document.getElementById("ingestionUploaded");
      const ingestionProcessing = document.getElementById("ingestionProcessing");
      const ingestionReady = document.getElementById("ingestionReady");
      const ingestionFailed = document.getElementById("ingestionFailed");
      const ingestionFailures = document.getElementById("ingestionFailures");
      const ingestionFailureList = document.getElementById("ingestionFailureList");
      const jobErrorRow = document.getElementById("jobErrorRow");
      const jobError = document.getElementById("jobError");

      let pollTimer = null;

      function setJobState(state) {
        jobStatus.textContent = state.status || "IDLE";
        jobProgress.textContent = state.progress || "";

        const ingestion = state.ingestion || null;
        if (
          ingestion &&
          (ingestion.uploaded || ingestion.processing || ingestion.ready || ingestion.failed)
        ) {
          ingestionRow.style.display = "block";
          ingestionUploaded.textContent = ingestion.uploaded || 0;
          ingestionProcessing.textContent = ingestion.processing || 0;
          ingestionReady.textContent = ingestion.ready || 0;
          ingestionFailed.textContent = ingestion.failed || 0;
        } else {
          ingestionRow.style.display = "none";
        }

        if (ingestion && ingestion.failures && ingestion.failures.length) {
          ingestionFailures.style.display = "block";
          ingestionFailureList.innerHTML = "";
          ingestion.failures.forEach((failure) => {
            const li = document.createElement("li");
            const path = failure.path ? ` (${failure.path})` : "";
            const status = failure.status ? `: ${failure.status}` : "";
            li.textContent = `${failure.fileId}${path}${status}`;
            ingestionFailureList.appendChild(li);
          });
        } else {
          ingestionFailures.style.display = "none";
          ingestionFailureList.innerHTML = "";
        }

        const errorMessage =
          (state.error && String(state.error)) ||
          (ingestion && ingestion.lastError ? String(ingestion.lastError) : "");
        if (errorMessage) {
          jobErrorRow.style.display = "block";
          jobError.textContent = errorMessage;
        } else {
          jobErrorRow.style.display = "none";
          jobError.textContent = "";
        }
      }

      async function poll() {
        const res = await fetch("/api/index/status");
        const state = await res.json();
        setJobState(state);

        if (state.status === "RUNNING") return;
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      runBtn &&
        runBtn.addEventListener("click", () => {
          confirmUpdateBox.style.display = "none";
          confirmReloadBox.style.display = "none";
          confirmBox.style.display = "block";
        });

      cancelBtn.addEventListener("click", () => {
        confirmBox.style.display = "none";
      });

      updateBtn &&
        updateBtn.addEventListener("click", async () => {
          const commit = (commitInput && commitInput.value ? commitInput.value : "").trim();
          if (!commit) {
            alert("Enter a target commit hash first.");
            return;
          }

          confirmBox.style.display = "none";
          confirmReloadBox.style.display = "none";
          confirmUpdateBox.style.display = "block";
          updateToCommit.textContent = commit;
          updateFromCommit.textContent = "Unknown";

          try {
            const res = await fetch("/api/metadata");
            if (res.ok) {
              const metadataState = await res.json();
              const lastIndexedCommit =
                metadataState &&
                metadataState.metadata &&
                metadataState.metadata.lastIndexedCommit
                  ? String(metadataState.metadata.lastIndexedCommit).trim()
                  : "";
              updateFromCommit.textContent = lastIndexedCommit ? lastIndexedCommit : "Not indexed";
            }
          } catch (e) {
            // ignore
          }
        });

      reloadBtn &&
        reloadBtn.addEventListener("click", () => {
          const commit = (commitInput && commitInput.value ? commitInput.value : "").trim();
          if (!commit) {
            alert("Enter a target commit hash first.");
            return;
          }

          confirmBox.style.display = "none";
          confirmUpdateBox.style.display = "none";
          confirmReloadBox.style.display = "block";
          reloadCommit.textContent = commit;
        });

      cancelUpdateBtn &&
        cancelUpdateBtn.addEventListener("click", () => {
          confirmUpdateBox.style.display = "none";
        });

      cancelReloadBtn &&
        cancelReloadBtn.addEventListener("click", () => {
          confirmReloadBox.style.display = "none";
        });

      confirmBtn.addEventListener("click", async () => {
        confirmBox.style.display = "none";
        const res = await fetch("/api/index/initial", { method: "POST" });
        const state = await res.json();
        setJobState(state);

        if (!pollTimer) {
          pollTimer = setInterval(poll, 500);
        }
        await poll();
      });

      confirmUpdateBtn &&
        confirmUpdateBtn.addEventListener("click", async () => {
          confirmUpdateBox.style.display = "none";
          const commit = (commitInput && commitInput.value ? commitInput.value : "").trim();
          const res = await fetch("/api/index/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ commit }),
          });
          const state = await res.json();
          setJobState(state);

          if (!pollTimer) {
            pollTimer = setInterval(poll, 500);
          }
          await poll();
        });

      confirmReloadBtn &&
        confirmReloadBtn.addEventListener("click", async () => {
          confirmReloadBox.style.display = "none";
          const commit = (commitInput && commitInput.value ? commitInput.value : "").trim();
          const res = await fetch("/api/index/reload", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ commit }),
          });
          const state = await res.json();
          setJobState(state);

          if (!pollTimer) {
            pollTimer = setInterval(poll, 500);
          }
          await poll();
        });

      poll();
      if (jobStatus.textContent === "RUNNING" && !pollTimer) {
        pollTimer = setInterval(poll, 500);
      }
    </script>
  </body>
</html>
